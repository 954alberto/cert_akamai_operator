# Motivation for this tool

Sending certificates obtained by cert-manager from a Kubernetes cluster to Akamai Kona (which is Akamai's Web Application Firewall (WAF) and security platform) could be necessary in various scenarios where your organization needs to integrate Kubernetes-managed certificates with Akamai's security and edge services. 

Below are some scenarios where this might be required:

## 1. SSL/TLS Termination at Akamai Edge
Scenario: You use Akamai to handle SSL/TLS termination at the edge for your web applications. Akamai Kona can provide DDoS protection, WAF security, and caching, but you still need to ensure encrypted traffic between Akamai and your Kubernetes services.
Reason: When SSL/TLS termination occurs at the edge (Akamai's global CDN), Akamai will need the certificates and private keys to establish secure connections with clients. However, if you are running Kubernetes-based services and want to maintain end-to-end encryption from the client all the way to your backend services, you may need to send certificates generated by cert-manager (or the Kubernetes Ingress controller) to Akamai for origin server authentication.

## 2. Custom SSL Certificates for Kubernetes Applications
Scenario: You have specific applications running within your Kubernetes cluster that require custom SSL certificates for HTTPS communication. Akamai Kona is acting as a proxy or intermediary for requests to these applications.
Reason: In this case, Akamai might need the SSL certificates that were automatically generated and managed by cert-manager to securely proxy requests to your Kubernetes applications. This ensures that both Akamai (at the edge) and the backend Kubernetes services communicate securely with the proper certificates.

## 3. Hybrid Infrastructure
Scenario: You are using a hybrid infrastructure, where part of your application is hosted in Kubernetes, while other parts of it might be hosted outside (on-prem or in another cloud). Akamai Kona acts as the common entry point for both.
Reason: If your Kubernetes workloads are communicating with external infrastructure through Akamai, you would need to provide Akamai with the appropriate certificates to ensure secure communication between the two environments. Cert-manager in Kubernetes can automatically issue certificates, and you would send these certificates to Akamai to ensure secure, authenticated traffic.

## 4. Automating SSL/TLS Certificate Deployment for Multi-Cloud Applications
Scenario: Your application is spread across multiple clouds (e.g., AWS and GCP), and your Kubernetes clusters on these platforms are generating their own SSL certificates. You want to centralize SSL/TLS management using Akamai's Kona as a single point for security enforcement.
Reason: In this case, once cert-manager generates and automates the SSL/TLS certificates for Kubernetes clusters in different clouds, you might need to synchronize or send the certificates to Akamai to ensure all incoming traffic is encrypted and inspected at the edge. Akamai then forwards traffic to the correct origin with the appropriate certificates.

## 5. Centralized Certificate Management
Scenario: Your organization wants to manage all SSL/TLS certificates in a centralized manner, even for traffic that goes through third-party services like Akamai.
Reason: If you are using cert-manager for internal certificate management, you might need to propagate or synchronize these certificates with Akamai to ensure all applications, whether deployed in Kubernetes or not, are using the latest certificates and configurations. This can help ensure compliance with security policies and reduce the manual overhead of certificate management.

## 6. Akamai as a Reverse Proxy with SSL Passthrough
Scenario: You use Akamai as a reverse proxy to forward traffic to your Kubernetes cluster, with SSL passthrough configured.
Reason: In such a setup, Akamai needs to pass the encrypted traffic to Kubernetes, but the backend Kubernetes services may still require the use of cert-manager to handle automatic certificate issuance. You may need to send the generated certificates to Akamai to allow it to proxy the traffic correctly while still maintaining secure communication.

## 7. SSL Offloading for Kubernetes-Hosted Services
Scenario: You want Akamai to offload SSL/TLS processing from your Kubernetes workloads, reducing the load on your Kubernetes nodes or pods.
Reason: In this case, Akamai needs the certificates to perform SSL offloading. While cert-manager is issuing certificates within the Kubernetes cluster, these need to be sent to Akamai so it can handle the SSL/TLS handshake and encryption. This is especially important when running large-scale applications where TLS termination at the edge is necessary for performance.
How You Might Send Certificates to Akamai
API Integration: You may need to use Akamai's API to programmatically send the certificates to Akamai Kona. This could be done by integrating cert-manager with Akamai's API via a custom script or operator.
Akamai Control Center: Alternatively, you may upload certificates manually through the Akamai Control Center or use Akamai's Property Manager to configure SSL settings with your desired certificates.

# Conclusion

In any scenario where Akamai Kona is acting as a reverse proxy, SSL/TLS terminator, or edge security service for Kubernetes-based workloads, sending certificates from cert-manager to Akamai ensures secure communication, proper certificate management, and compliance with organizational security standards. This is especially important when you're using Akamai's advanced WAF, DDoS protection, and caching features while also ensuring that traffic between Akamai and Kubernetes services is encrypted.

----------

# Explanation of Key Components:

## Kubernetes Client:

We use the kube crate to interact with the Kubernetes API.
Informer allows us to watch resources such as Secret and trigger actions when the secret is applied or updated.

## Watching the Secret:

The Informer::run() function monitors changes to the Kubernetes resources (here, the Secret).
When a secret is applied or updated, the operator triggers handle_secret() to extract the certificate and other details.

## Handling the Certificate:

handle_secret() extracts the certificate (tls.crt), private key (tls.key), and the certificate chain (tls.ca.crt) from the Kubernetes Secret.
Then it calls push_to_akamai() to upload these details to Akamai using their API.

## Pushing to Akamai:

We use the reqwest crate to send an HTTP POST request to Akamai’s API, uploading the certificate details in base64 encoding.

## Async Runtime:

Rust’s async ecosystem (using tokio here) is used to manage asynchronous operations efficiently. This is particularly useful for I/O-bound tasks like interacting with the Kubernetes API and making HTTP requests to Akamai.

## Run the Operator

After you write the operator, you can run it locally or build a Docker image to deploy it to your Kubernetes cluster.

To build the Rust operator:

```bash
cargo build --release
```
You can then deploy the operator to your Kubernetes cluster using a Deployment manifest. For example:

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: cert-akamai-operator
spec:
  replicas: 1
  selector:
    matchLabels:
      app: cert-akamai-operator
  template:
    metadata:
      labels:
        app: cert-akamai-operator
    spec:
      containers:
      - name: cert-akamai-operator
        image: your-docker-image
        imagePullPolicy: Always
```
5. Deploying to Kubernetes
After building the image and pushing it to your container registry, you can create a Kubernetes Deployment to deploy your operator.

## Conclusion:
This Rust-based operator listens for changes in Kubernetes Secret resources that Cert-Manager manages, extracts the certificate data, and pushes it to Akamai using their API. This approach leverages Kubernetes’ async processing with Rust's high-performance capabilities.